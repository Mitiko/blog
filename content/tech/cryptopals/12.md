+++
title = "Byte-at-a-time ECB decryption"
date  = 2023-10-21

[extra]
subtitle = "(Simple)"
+++

Few words..

## Setup

### 1. Store the secret

Few more words..

```rust
use lazy_static::lazy_static;
use crate::utils::conversions::*;

lazy_static! {
    static ref SECRET: Vec<u8> = base64_to_raw(
        "Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg
        aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq
        dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg
        YnkK"
    );
}

// Or just store it base64 encoded as a const:
const SECRET: &str = "/* ... */";
```

<details>
<summary>C# version</summary>

_Test project using MSTest_

As a field:
```c#
[TestClass]
public class Set2
{
    private readonly byte[] Secret = Base64Decode(
        @"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg
        aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq
        dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg
        YnkK"
    );
}
```

As a property:
```c#
[TestClass]
public class Set2
{
    private byte[] Secret
    {
        get => Base64Decode(
            @"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg
            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq
            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg
            YnkK"
        );
    }
}
```
</details>

<details>
<summary>JavaScript version</summary>

```js
const SECRET = atob("\
    Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\
    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\
    dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\
    YnkK\
");
```

</details>

### 2. Write the vulnerable function

```rust
fn vulnerable_fn(plaintext: &[u8]) -> Vec<u8> {
    // 1. generate a random 16-byte key (seeded rng)
    // 2. base64 decode the secret
    // 3. data = plaintext + suffix
    // 4. pkcs7 pad data
    // 5. encrypt
    todo!()
}

#[test]
fn challange12() {
    /* ... */
    assert_eq!(deciphered, base64_to_raw(SECRET));
}
```

### 3. Write a function to detect the block size

```rust
fn detect_block_size<F>(insecure_fn: F) -> usize
    where F: Fn(&[u8]) -> Vec<u8>,
{
    // vary input length until output length spikes
    // output length change is block size
    todo!()
}
```

The function signature might be a bit different in other languages but do try to
make it generic over the encryption function.

### 4. Write a function to detect the cipher mode

```rust
enum Mode { ECB, CBC }

// simple _generic_ wrapper around the code from challange 11
fn detect_cipher_mode(insecure_fn: F) -> Mode
    where F: Fn(&[u8]) -> Vec<u8>
{
    todo!()
}
```



